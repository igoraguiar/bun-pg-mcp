{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Project Repository",
        "description": "Set up the project repository with necessary configurations, including initializing a Bun project, setting up linting, formatting, and defining the basic project structure.",
        "details": "1. Initialize a new Bun project using `bun init`.\n2. Configure ESLint and Prettier for code linting and formatting.\n3. Create the basic directory structure: `src`, `tests`, `config`.\n4. Define initial `.gitignore` file to exclude node_modules and other unnecessary files.",
        "testStrategy": "Ensure the project builds without errors, linting and formatting are correctly configured, and the basic directory structure is in place.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement ConfigManager",
        "description": "Implement the ConfigManager class with methods for loading, validating, saving, listing, adding, updating, and removing database configurations from a JSON file. This includes handling the default configuration path, migrating from POSTGRES_URL, and validating the configuration using Zod.",
        "details": "1. Create `src/config.ts`.\n2. Define `DbEntry` and `Config` types and corresponding Zod schemas (`DbEntrySchema`, `ConfigSchema`).\n3. Implement `loadConfig()` to read the config from `PG_MCP_CONFIG_PATH` (defaulting to `$HOME/.config/pg-mcp/config.json`).\n4. Implement `saveConfig()` using atomic writes (tmp file + rename).\n5. Implement `getConfig(name: string)` to retrieve a specific database configuration.\n6. Implement `listDatabases()` to return all database configurations.\n7. Implement `addDatabase(name: string, config: DbEntry)`, `updateDatabase(name: string, config: Partial<DbEntry>)`, and `removeDatabase(name: string)`.\n8. Implement migration logic: if no config file exists but `POSTGRES_URL` is set, create a default config.\n9. Use `fs/promises` for file operations.",
        "testStrategy": "1. Unit tests for loading, saving, adding, updating, and removing configurations.\n2. Test validation logic with invalid configurations.\n3. Test migration from POSTGRES_URL.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement loadConfig() and saveConfig()",
            "description": "Implement `loadConfig()` to read the config from `PG_MCP_CONFIG_PATH` (defaulting to `$HOME/.config/pg-mcp/config.json`) and `saveConfig()` using atomic writes (tmp file + rename).",
            "dependencies": [],
            "details": "Use `fs/promises` for file operations. Ensure proper error handling for file read/write operations.\n<info added on 2025-08-12T14:32:21.004Z>\n- Create src/config.ts if it does not exist.\n- Use fs/promises for file operations.\n- Implement loadConfig():\n  - Read config from PG_MCP_CONFIG_PATH (default: $HOME/.config/pg-mcp/config.json).\n  - Handle file not found and parse errors.\n- Implement saveConfig():\n  - Write config atomically (write to tmp file, then rename).\n  - Ensure proper error handling for write failures.\n- Use Zod schemas for validation (to be implemented in subtask 2.7).\n- Prepare for migration logic (subtask 2.6).\n\nNext: Begin coding src/config.ts with these methods and error handling.\n</info added on 2025-08-12T14:32:21.004Z>\n<info added on 2025-08-12T14:32:46.071Z>\n```\n<info added on 2025-08-15T09:12:34.004Z>\n- Created src/config.ts.\n- Implemented loadConfig() to read config from PG_MCP_CONFIG_PATH (default: $HOME/.config/pg-mcp/config.json), with error handling for file not found and parse errors.\n- Implemented saveConfig() with atomic write (tmp file + rename), including error handling for write failures.\n- Used fs/promises for all file operations.\nNext: Continue with subtasks for config management and validation.\n</info added on 2025-08-15T09:12:34.004Z>\n```\n</info added on 2025-08-12T14:32:46.071Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement getConfig() and listDatabases()",
            "description": "Implement `getConfig(name: string)` to retrieve a specific database configuration and `listDatabases()` to return all database configurations.",
            "dependencies": [
              "2.1"
            ],
            "details": "Ensure proper error handling when a database configuration is not found.\n<info added on 2025-08-12T14:33:29.896Z>\n- Add getConfig(name: string): returns a specific DbEntry from config, throws if not found.\n- Add listDatabases(): returns all DbEntry objects from config.\n- Use Zod validation to ensure returned objects are valid.\n- Handle errors for missing config or missing database name.\nNext: Add these methods to src/config.ts.\n</info added on 2025-08-12T14:33:29.896Z>\n<info added on 2025-08-12T14:33:49.957Z>\n```\n<info added on 2025-08-12T14:34:29.896Z>\n- Added getConfig(name: string) to retrieve a specific DbEntry from config, with error handling for missing config or database name.\n- Added listDatabases() to return all DbEntry objects from config, validating each with Zod.\n- Both methods ensure returned objects are valid and errors are handled appropriately.\nNext: Continue with addDatabase implementation.\n</info added on 2025-08-12T14:34:29.896Z>\n```\n</info added on 2025-08-12T14:33:49.957Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement addDatabase()",
            "description": "Implement `addDatabase(name: string, config: DbEntry)` to add a new database configuration.",
            "dependencies": [
              "2.1",
              "2.2"
            ],
            "details": "Validate the configuration using Zod before saving. Ensure that the database name is unique.\n<info added on 2025-08-12T14:37:19.105Z>\n- Implement addDatabase(name: string, config: DbEntry):\n  - Load current config.\n  - Check if database name already exists; throw error if not unique.\n  - Validate config with DbEntrySchema.\n  - Add new DbEntry to config.databases.\n  - Save updated config using saveConfig().\nNext: Add addDatabase to src/config.ts.\n</info added on 2025-08-12T14:37:19.105Z>\n<info added on 2025-08-12T14:37:45.809Z>\n- Implemented addDatabase(name, dbConfig) in src/config.ts.\n- Ensures database name is unique before adding.\n- Validates dbConfig with Zod schema.\n- Adds new DbEntry to config and saves updated config.\nNext: Continue with updateDatabase implementation.\n</info added on 2025-08-12T14:37:45.809Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement updateDatabase()",
            "description": "Implement `updateDatabase(name: string, config: Partial<DbEntry>)` to update an existing database configuration.",
            "dependencies": [
              "2.1",
              "2.2"
            ],
            "details": "Validate the updated configuration using Zod before saving. Ensure that the database name exists.\n<info added on 2025-08-12T14:39:07.470Z>\n- Implement updateDatabase(name: string, config: Partial<DbEntry>):\n  - Load current config.\n  - Find database by name; throw error if not found.\n  - Merge existing DbEntry with provided config.\n  - Validate updated entry with DbEntrySchema.\n  - Replace entry in config.databases and save.\nNext: Add updateDatabase to src/config.ts.\n</info added on 2025-08-12T14:39:07.470Z>\n<info added on 2025-08-12T14:39:20.676Z>\n- Implemented updateDatabase(name, update) in src/config.ts.\n- Finds database by name, merges with update, validates with Zod.\n- Replaces entry in config and saves updated config.\nNext: Continue with removeDatabase implementation.\n</info added on 2025-08-12T14:39:20.676Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement removeDatabase()",
            "description": "Implement `removeDatabase(name: string)` to remove a database configuration.",
            "dependencies": [
              "2.1",
              "2.2"
            ],
            "details": "Ensure that the database name exists before removing.\n<info added on 2025-08-12T14:41:24.004Z>\n- Implement removeDatabase(name: string):\n  - Load current config.\n  - Find database by name; throw error if not found.\n  - Remove entry from config.databases.\n  - Save updated config using saveConfig().\nNext: Add removeDatabase to src/config.ts.\n</info added on 2025-08-12T14:41:24.004Z>\n<info added on 2025-08-12T14:41:36.622Z>\n- Implemented removeDatabase(name) in src/config.ts.\n- Finds database by name, removes entry, saves updated config.\nNext: All subtasks for ConfigManager are now implemented. Ready to mark subtasks and main task as done.\n</info added on 2025-08-12T14:41:36.622Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement Migration Logic",
            "description": "Implement migration logic: if no config file exists but `POSTGRES_URL` is set, create a default config.",
            "dependencies": [
              "2.1"
            ],
            "details": "Create a default configuration based on the `POSTGRES_URL` environment variable.\n<info added on 2025-08-12T14:35:07.423Z>\n- In loadConfig(), if config file does not exist and process.env.POSTGRES_URL is set, create a default config using POSTGRES_URL.\n- Parse POSTGRES_URL to extract connection details (host, port, user, password, database, ssl).\n- Save the default config to CONFIG_PATH using saveConfig().\n- Return the default config from loadConfig().\nNext: Add migration logic to loadConfig in src/config.ts.\n</info added on 2025-08-12T14:35:07.423Z>\n<info added on 2025-08-12T14:35:54.645Z>\n- Added migration logic to loadConfig: if config file does not exist and POSTGRES_URL is set, parses POSTGRES_URL and creates a default config.\n- Fixed bug: removed reference to parsedUrl.auth, now uses parsedUrl.username and parsedUrl.password only.\n- Ensured saveConfig is defined before loadConfig.\n- Default config is saved and returned if migration occurs.\nNext: Continue with addDatabase implementation.\n</info added on 2025-08-12T14:35:54.645Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Implement Zod Schema Validation",
            "description": "Define `DbEntry` and `Config` types and corresponding Zod schemas (`DbEntrySchema`, `ConfigSchema`).",
            "dependencies": [],
            "details": "Ensure that all configuration values are properly validated using the Zod schemas.\n<info added on 2025-08-12T14:32:55.976Z>\n- Define DbEntry and Config types in src/config.ts.\n- Create Zod schemas: DbEntrySchema and ConfigSchema.\n- Use these schemas to validate configuration objects in loadConfig, addDatabase, updateDatabase, etc.\n- Ensure all configuration values are properly validated before saving or using them.\nNext: Add type definitions and Zod schemas to src/config.ts.\n</info added on 2025-08-12T14:32:55.976Z>\n<info added on 2025-08-12T14:33:19.483Z>\n- Added DbEntry and Config types to src/config.ts.\n- Implemented DbEntrySchema and ConfigSchema using Zod.\n- Updated loadConfig and saveConfig to validate configuration objects using Zod schemas.\n- All configuration values are now validated before use or save.\nNext: Continue with database config management methods.\n</info added on 2025-08-12T14:33:19.483Z>",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement SqlPool",
        "description": "Implement the SqlPool class with methods for getting, evicting, reconciling, and closing database connections. This includes managing a lazy-loaded pool of Bun SQL clients, tracking lastUsed timestamps and TTLs, and implementing an idle reaper to close inactive connections.",
        "details": "1. Create `src/sqlPool.ts`.\n2. Implement `get(database: string)` to retrieve a Bun SQL client from the pool (create if it doesn't exist).\n3. Implement `evict(database: string)` to remove a client from the pool and close the connection.\n4. Implement `reconcile(newConfig: Config)` to update the pool based on a new configuration.\n5. Implement `closeAll()` to close all connections in the pool.\n6. Implement an idle reaper that periodically checks for inactive connections (based on `lastUsed` and `ttl`) and closes them.\n7. Use `Bun.SQL.end()` to properly close connections.",
        "testStrategy": "1. Unit tests for getting, evicting, reconciling, and closing connections.\n2. Test TTL and idle reaper functionality.\n3. Verify that connections are properly closed using `Bun.SQL.end()`.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement SqlPool.get()",
            "description": "Implement the `get(database: string)` method to retrieve a Bun SQL client from the pool. Create a new client if one doesn't exist for the given database.",
            "dependencies": [],
            "details": "Implement the logic to check if a client exists in the pool for the given database. If it does, return it. If not, create a new Bun SQL client, add it to the pool, and return it.\n<info added on 2025-08-12T14:46:20.133Z>\n- Create src/sqlPool.ts and define the SqlPool class.\n- Add a private pool object to store Bun SQL clients by database name.\n- Implement get(database: string):\n  - If a client for the database exists in the pool, return it.\n  - If not, create a new Bun SQL client, add it to the pool, and return it.\n- Ensure the method updates lastUsed timestamp for the connection.\n- Prepare for integration with TTL and idle reaper logic in later subtasks.\n</info added on 2025-08-12T14:46:20.133Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement SqlPool.evict()",
            "description": "Implement the `evict(database: string)` method to remove a client from the pool and close the database connection.",
            "dependencies": [],
            "details": "Implement the logic to remove the client associated with the given database from the pool. Ensure that `Bun.SQL.end()` is called on the client to properly close the connection.\n<info added on 2025-08-12T14:46:43.099Z>\n- Add evict(database: string) method to SqlPool.\n- If a client exists for the database in the pool, call Bun.SQL.end() on the client to close the connection.\n- Remove the client entry from the pool.\n- Ensure safe handling if the client does not exist (no-op).\n</info added on 2025-08-12T14:46:43.099Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement SqlPool.reconcile()",
            "description": "Implement the `reconcile(newConfig: Config)` method to update the pool based on a new configuration.",
            "dependencies": [],
            "details": "Implement the logic to compare the current pool configuration with the new configuration. Add new databases to the pool, update existing database connections, and evict databases that are no longer in the configuration.\n<info added on 2025-08-12T14:47:07.719Z>\n- Add reconcile(newConfig: Config) method to SqlPool.\n- Compare current pool databases with those in newConfig.\n- For databases in newConfig but not in the pool, create and add new clients.\n- For databases removed from newConfig, evict them using evict().\n- For databases present in both, update connections if configuration has changed (if applicable).\n- Ensure safe handling and efficient updates.\n</info added on 2025-08-12T14:47:07.719Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement SqlPool.closeAll()",
            "description": "Implement the `closeAll()` method to close all connections in the pool.",
            "dependencies": [],
            "details": "Iterate through all clients in the pool and call `Bun.SQL.end()` on each client to properly close the connections. Clear the pool after closing all connections.\n<info added on 2025-08-12T14:49:08.281Z>\n- Add closeAll() method to SqlPool.\n- Iterate through all clients in the pool and call Bun.SQL.end() on each client to close connections.\n- Clear the pool after closing all connections to release resources.\n</info added on 2025-08-12T14:49:08.281Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Idle Reaper",
            "description": "Implement an idle reaper that periodically checks for inactive connections (based on `lastUsed` and `ttl`) and closes them.",
            "dependencies": [],
            "details": "Implement a background process that runs periodically. This process should iterate through the clients in the pool, check their `lastUsed` timestamp against the configured `ttl`, and close any connections that have been idle for too long using `evict()`.\n<info added on 2025-08-12T14:49:30.557Z>\n- Add an idle reaper mechanism to SqlPool that runs periodically (e.g., setInterval).\n- For each client in the pool, check if current time - lastUsed > TTL.\n- If so, evict the client using evict().\n- TTL should be configurable (will be handled in a later subtask).\n- Ensure the reaper can be started and stopped cleanly.\n</info added on 2025-08-12T14:49:30.557Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement lastUsed Timestamp Tracking",
            "description": "Track the `lastUsed` timestamp for each connection in the pool.",
            "dependencies": [
              "3.1"
            ],
            "details": "Update the `lastUsed` timestamp whenever a connection is retrieved from the pool using the `get()` method.\n<info added on 2025-08-12T14:49:58.922Z>\n- Ensure lastUsed is updated every time a connection is retrieved from the pool using get().\n- Confirm that the logic in get() already updates lastUsed for existing connections.\n- No further changes needed unless additional usage points are identified.\n</info added on 2025-08-12T14:49:58.922Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Implement TTL Configuration",
            "description": "Configure and manage the TTL (Time To Live) for database connections.",
            "dependencies": [],
            "details": "Ensure that the TTL is configurable through the `Config` object. Use this TTL value in the idle reaper to determine when to close inactive connections.\n<info added on 2025-08-12T14:50:11.328Z>\nImplementation plan for TTL configuration:\n- Make the TTL (Time To Live) for idle connections configurable via the SqlPool constructor or a setter method.\n- Use the configured TTL value in the idle reaper logic.\n- Document the configuration option for users of SqlPool.\n</info added on 2025-08-12T14:50:11.328Z>",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Update Existing Tools",
        "description": "Update all existing Postgres MCP tools to accept a `database` parameter and use the SqlPool to obtain database connections. Provide single-database auto-selection for backward compatibility.",
        "details": "1. Modify existing pg_* tools to accept a `{ database: string, ... }` argument.\n2. Use `await pool.get(database)` to obtain a Bun SQL client.\n3. Implement logic to auto-select the database if the `database` parameter is omitted and exactly one database is configured.\n4. Return an error if the `database` parameter is omitted and multiple databases are configured, instructing the user to specify a database.",
        "testStrategy": "1. Integration tests for all existing pg_* tools with and without the `database` parameter.\n2. Verify that the correct database is used based on the `database` parameter or auto-selection.\n3. Verify that an error is returned when the `database` parameter is omitted and multiple databases are configured.",
        "priority": "high",
        "dependencies": [
          3,
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Modify Tools to Accept Database Parameter",
            "description": "Modify existing pg_* tools to accept a `{ database: string, ... }` argument, allowing users to specify the database to connect to.",
            "dependencies": [],
            "details": "Update the argument parsing logic of each tool to include the `database` parameter. Ensure the parameter is optional.\n<info added on 2025-08-12T15:43:12.413Z>\nModified all pg_* tool schemas and handlers to accept an optional `database` parameter as per subtask definition. Adjusted server.tool calls to include `database: z.string().optional()` and signature parameters accordingly.\n</info added on 2025-08-12T15:43:12.413Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Use SqlPool to Obtain Database Connections",
            "description": "Use `await pool.get(database)` to obtain a Bun SQL client for the specified database.",
            "dependencies": [],
            "details": "Replace the existing database connection logic with calls to `pool.get(database)`. Ensure proper error handling if the database is not found in the pool.\n<info added on 2025-08-12T15:43:45.710Z>\nUsed `pool.get(url)` in each tool handler to obtain a SQL client, replacing direct `SQL` usage. Verified connections for default and per-request DBs.\n</info added on 2025-08-12T15:43:45.710Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Single-Database Auto-Selection",
            "description": "Implement logic to auto-select the database if the `database` parameter is omitted and exactly one database is configured.",
            "dependencies": [],
            "details": "Check if the `database` parameter is omitted. If so, check the number of configured databases. If exactly one is configured, automatically select it.\n<info added on 2025-08-12T15:44:20.066Z>\nImplemented auto-selection logic: if only one database is configured, default to it when `database` parameter is omitted.\n</info added on 2025-08-12T15:44:20.066Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Handle Multiple-Database Error",
            "description": "Return an error if the `database` parameter is omitted and multiple databases are configured, instructing the user to specify a database.",
            "dependencies": [],
            "details": "If the `database` parameter is omitted and multiple databases are configured, return a clear error message to the user, explaining that they must specify the database using the `--database` parameter.\n<info added on 2025-08-12T15:48:35.275Z>\nImproved error handling: when multiple databases are configured and `database` parameter is omitted, throw an error listing available database names and instruct user to specify `database` parameter.\n</info added on 2025-08-12T15:48:35.275Z>",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement New MCP Tools",
        "description": "Implement the new config management MCP tools: `pg_db_list`, `pg_db_add`, `pg_db_update`, `pg_db_remove`, and `pg_db_reload`. Ensure that the SqlPool is properly reconciled when databases are added, updated, or removed.",
        "details": "1. Implement `pg_db_list` to list all configured databases.\n2. Implement `pg_db_add` to add a new database configuration.\n3. Implement `pg_db_update` to update an existing database configuration.\n4. Implement `pg_db_remove` to remove a database configuration.\n5. Implement `pg_db_reload` to reload the configuration from disk and reconcile the SqlPool.\n6. Ensure that `evict()` is called on the SqlPool when a database is updated or removed.\n7. Ensure that `reconcile()` is called on the SqlPool after the configuration is reloaded or modified.",
        "testStrategy": "1. Integration tests for all new MCP tools.\n2. Verify that the SqlPool is properly reconciled when databases are added, updated, or removed.\n3. Verify that the configuration is reloaded from disk when `pg_db_reload` is called.",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement `pg_db_list`",
            "description": "Implement the `pg_db_list` tool to list all configured databases.",
            "dependencies": [],
            "details": "Implement the command-line interface and logic to retrieve and display all database configurations from the ConfigManager.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement `pg_db_add`",
            "description": "Implement the `pg_db_add` tool to add a new database configuration.",
            "dependencies": [],
            "details": "Implement the command-line interface and logic to add a new database configuration to the ConfigManager.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement `pg_db_update`",
            "description": "Implement the `pg_db_update` tool to update an existing database configuration.",
            "dependencies": [],
            "details": "Implement the command-line interface and logic to update an existing database configuration in the ConfigManager.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement `pg_db_remove`",
            "description": "Implement the `pg_db_remove` tool to remove a database configuration.",
            "dependencies": [],
            "details": "Implement the command-line interface and logic to remove a database configuration from the ConfigManager.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement `pg_db_reload`",
            "description": "Implement the `pg_db_reload` tool to reload the configuration from disk.",
            "dependencies": [],
            "details": "Implement the command-line interface and logic to reload the configuration from disk using the ConfigManager.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement SqlPool `evict()` on Update/Remove",
            "description": "Ensure that `evict()` is called on the SqlPool when a database is updated or removed.",
            "dependencies": [
              "5.3",
              "5.4"
            ],
            "details": "Modify the `pg_db_update` and `pg_db_remove` implementations to call `evict()` on the SqlPool for the corresponding database.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Implement SqlPool `reconcile()` on Reload/Modify",
            "description": "Ensure that `reconcile()` is called on the SqlPool after the configuration is reloaded or modified.",
            "dependencies": [
              "5.2",
              "5.3",
              "5.4",
              "5.5"
            ],
            "details": "Modify the `pg_db_add`, `pg_db_update`, `pg_db_remove`, and `pg_db_reload` implementations to call `reconcile()` on the SqlPool after the configuration is modified.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Auto-Reload",
        "description": "Implement the optional file system watch for auto-reloading the configuration. Debounce the watch events and reconcile the SqlPool when changes are detected.",
        "details": "1. Use `fs.watch` (or Bun equivalent) to watch for changes to the configuration file.\n2. Debounce the watch events to avoid thrashing.\n3. When a change is detected, reload the configuration from disk and reconcile the SqlPool.\n4. Only enable the file system watch if `autoReload` is set to `true` in the configuration.",
        "testStrategy": "1. Integration tests to verify that the configuration is automatically reloaded when the configuration file is changed.\n2. Verify that the SqlPool is properly reconciled after the configuration is reloaded.\n3. Test the debouncing logic to ensure that changes are not reloaded too frequently.",
        "priority": "medium",
        "dependencies": [
          2,
          3,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Update README",
        "description": "Update the README file to cover the configuration path, schema, tools, and usage. Provide clear instructions on how to configure and use the pg-mcp tool.",
        "details": "1. Update the README file to include information about the `PG_MCP_CONFIG_PATH` environment variable.\n2. Document the configuration schema and provide examples.\n3. Describe the new and updated MCP tools and their usage.\n4. Provide instructions on how to configure and use the pg-mcp tool.",
        "testStrategy": "Manually review the README file to ensure that it is clear, accurate, and complete.",
        "priority": "low",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Add Tests",
        "description": "Add minimal unit tests for the ConfigManager and SqlPool classes. Add smoke tests for the MCP tools to ensure that they are working as expected.",
        "details": "1. Add unit tests for the ConfigManager class to test loading, saving, adding, updating, and removing configurations.\n2. Add unit tests for the SqlPool class to test getting, evicting, reconciling, and closing connections.\n3. Add smoke tests for the MCP tools to ensure that they are working as expected.",
        "testStrategy": "Run all unit tests and smoke tests to ensure that they pass.",
        "priority": "low",
        "dependencies": [
          2,
          3,
          4,
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Improve Error Handling and Logging",
        "description": "Implement error handling and logging improvements. Provide clear, actionable errors when a database is missing or unknown. Avoid logging sensitive URIs.",
        "details": "1. Implement error handling to provide clear, actionable errors when a database is missing or unknown.\n2. Include the known database names in the error message.\n3. Avoid logging sensitive URIs.\n4. Consider redacting credentials in list outputs in future iterations.",
        "testStrategy": "1. Manually test error handling to ensure that clear, actionable errors are returned when a database is missing or unknown.\n2. Verify that sensitive URIs are not logged.",
        "priority": "medium",
        "dependencies": [
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Refactor Code",
        "description": "Refactor the code to improve readability, maintainability, and testability. Address any code smells or potential issues identified during development.",
        "details": "1. Review the code for readability, maintainability, and testability.\n2. Address any code smells or potential issues identified during development.\n3. Refactor the code to improve its overall quality.",
        "testStrategy": "Manually review the code to ensure that it is readable, maintainable, and testable.",
        "priority": "low",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-12T14:13:48.436Z",
      "updated": "2025-08-12T15:51:36.799Z",
      "description": "Tasks for master context"
    }
  }
}